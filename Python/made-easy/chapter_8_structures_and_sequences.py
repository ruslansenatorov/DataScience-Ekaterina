# ---
# jupyter:
#   jupytext:
#     text_representation:
#       extension: .py
#       format_name: light
#       format_version: '1.5'
#       jupytext_version: 1.16.4
#   kernelspec:
#     display_name: Python 3
#     language: python
#     name: python3
# ---

"""Структуры данных и последовательности."""

import random

from typing import List

# Название «структуры данных» говорит само за себя. Это структуры, в которых
# совместно хранятся определенные данные.
# В Python есть четыре встроенных структуры данных.
# ♦ списки;
# ♦ кортежи;
# ♦ множества;
# ♦ словари.
#
# 8.1. Строки
# Строки являются объектами в Python, а именно экземплярами класса str.
# В Python все типы данных являются классами. В Python класс - это определение 
# объекта, а объект - это экземШIЯр класса.
# Строки можно задать несколькими способами. Их можно заключать в одинарные
# ( ' ' ) или двойные кавычки ("") - результат будет одинаковый. Их также можно за
# ключать в три кавычки, одинарные или двойные. Использование трех кавычек дает
# возможность записывать строки более чем в одну строку. Примеры:
# 'строка ', "строка ", '''строка''', """ строка"""
# 8.1.1. Строковые операции
# Строки - это объекты, и, как у любых объектов, у них есть методы, которые мож
# но применять. 

x_ = "nilabh"
print(x_)

x_ = "nilabh".capitalize()
print(x_)

x_ = "nilabh".upper()
print(x_)

x_ = "Nilabh".swapcase()
print(x_)

# Строки - это неизменяемые объекты. При изменении каждая строковая операция
# создает новый объект.

s1 = "Nilabh"
s2 = "Nilabh"
# nроверим, являются ли s1 и s2 одним и тем же объектом
s1 is s2

# убедимся, проверив идентификаторы
print(id(s1))
print(id(s2))

s3 = s1.upper()
print(s3 is s1)
print(id(s3))
print(id(s1))

# 8.1.2. Форматирование
# Теперь посмотрим, что делает метод format(). Для использования этого метода 
# в строке должны быть заполнители, в которые помещаются аргументы метода 
# format() при выполнении. Это позиционный метод, если не указано иное. 
# Это означает, что аргументы в результирующей строке появляются на тех же
# позициях, что и в format(). 

# 8 , 9 и "ten" появятся в указанном порядке
x_ = f"seven, {8}, {9} and {'ten'}"
print(x_)

# Мы можем изменить очередность, указав позиции аргументов в заполнителях.

x_ = f"seven, {'ten'}, {9} and {8}"
print(x_)

# Метод format ( ) также можно использовать для выравнивания строк и создания
# строки нужной длины. Если исходная строка короче, она будет дополнена пробе-
# лами.

# 8 , 9 и "ten" будут дополнены пробелами справа или слева,
# в зависимости от знака ' < ' или ' > ' после двоеточия
x_ = f"seven,{'ten':<9}, {9:>9} and {8:9} "
print(x_)

# Cтроки прижимаются к левому или правому краю в направлении символов (<) или
# (>) соответственно. Так, строка "ten" выровнена по левому краю, а правая
# часть дополнена пробелами.
# Существует другой способ форматирования строк, этот метод называется f-строками.

# В f-строках можно использовать переменные в заполнителях
a_ = "8"
b_ = "9"
c_ = "ten"
x_ = f"seven, {a_} , {b_} and {c_} "
print(x_)

# 8.1.3. Методы split() и join()
# Разделить строку можно с помощью метода split(). Python находит в строке пробелы
# и символы переноса и возвращает список всех слов из строки.

text = "Put several strings within parentheses "
"to have them joined together."
print(text.split())

# По умолчанию метод split() делит строку по пробелам. Но мы можем изменить это
# поведение.

print(text.split("i"))

split_text = text.split()
print(split_text)

join_text = " ".join(split_text)
print(join_text)

# Список слов можно объединять с помощью любой строки.

join_text = "-".join(split_text)
print(join_text)

# 8.2. Списки
# У списков в Python есть важные 3 свойства:
# ♦ упорядоченность;
# ♦ последовательность;
# ♦ итерируемость.

# +
list_of_movies = [
    "Побег из Шоушенка",
    "Крестный отец",
    "Аватар",
    "Терминатор-2: Судный день",
    "24 часа",
    "12 разгневанных мужчин",
    "Три амигос!",
    "Игра престолов",
]

list_of_movies
# -

# После создания в список можно вносить изменения с помощью различных
# функций и операций над списками. Можно добавлять, удалять и искать элемен-
# ты в списке. Список является изменяемым типом данных.
# Список - это просто контейнер. У этого контейнера есть некоторые свойства,
# которые делают его простым и полезным в использовании.

# 8.2.1. Индексы и срезы
# Как и строки (и другие встроенные типы последовательностей), списки можно ин-
# дексировать и делать срезы.

even = [2, 4, 6, 8, 10, 12, 14]
even[0]

even[-1]

even[1:4]

even + [16, 18, 20, 22]

# В отличие от неизменяемых строк, списки являются изменяемым типом данных,
# т.е. их содержимое можно изменять.

squares = [1, 4, 9, 17, 25]  # квадраты чисел, с ошибкой
# 4 в квадрате равно 16, а не 17 !
squares

squares[3] = 16
squares

# Встроенная функция len( ) также применима к спискам.

len(squares)

# 8.2.2. Методы списков
#
# list.append(x) - Добавление элемента х в конец списка. Эквивалентно а[len(а):] = [х]
# list.extend(iterable) - Добавление в список всех элементов из iterable. Эквивалентно
# a[len(a):] = iterable
# list.insert(i, х)  - Вставка элемента х на заданную позицию. Первый аргумент - это
# индекс элемента, перед которым нужно выполнить вставку, поэтому a.insert (О, х)
# вставляет элемент в начало списка, а а.insert(len(а), х) эквивалентно a.append (х)
# list.remove(х)  - Удаление из списка первого элемента, значение которого равно х.
# Если такого элемента нет, возникает ошибка valueError
# list.pop([i])  - Удаляет элемент в данной позиции в списке и возвращает его. Если
# индекс не указан, а.рор() удаляет и возвращает последний элемент в списке. 
# (Квадратные скобки вокруг i в сигнатуре метода означают, что этот параметр
# является необязательным и не нужно печатать эти скобки при вызове метода.
# Это обозначение часто встречается в справочниках по библиотекам Python.)
# list.clear() - Удаляет все элементы из списка. Эквивалентно del а [:
# list.index(x [, start [ , end] ] )Возвращает индекс первого элемента, значение 
# которого равно х. Возвращает ошибку valueError, если такого элемента нет. 
# Необязательные аргументы start и end интерпретируются как срез и используются
# для ограничения области поиска в списке. Возвращается индекс относительно начала
# списка, а не от аргумента start
# list.count(x) - Сколько раз значение х встречается в списке
# list.sort([key=None, reverse=False]) - Сортирует элементы списка (необязательные аргументы
# можно использовать для настройки сортировки)
# list.reverse()  - Меняет порядок элементов списка на обратный
# list.сору() - Возвращает копию списка. Эквивалентно [:]

fruits = ["orange", "apple", "pear", "banana", "kiwi ", "apple", "banana"]
fruits

fruits.count("tangerline")

fruits.index("banana")

fruits.index("banana", 4)

fruits.reverse()
fruits

fruits.append("grape")

fruits.sort()
fruits

fruits.pop()

# 8.2.3. Списковые включения
# Списковые включения - это краткий и элегантный способ создания списков. Базо-
# вая струюура спискового включения выглядит следующим образом:
# результат = [ вьражение for элемент in список if условие]

# [i_ for i_ in "asia"]
list("asia")

# mylist = [i_ for i_ in range(10)]
my_list = list(range(10))
my_list

evens = [i_ for i_ in range(20) if i_ % 2 == 0]
evens

# my_list = ["x", "y", "z"]
# new_list = [i_ * n_ for i_ in my_list for n_ in range(1, 5)]
# new_list

# Мы хотим создать вот такой список: [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)].
#

# # создание списка с помощью цикла for
# combs = []
# for x_ in [1, 2, 3]:
#     for y_ in [3, 1, 4]:
#         if x_ != y_:
#             combs.append((x_, y_))
# combs

# создание списка с помощью спискового включения
[(x_, y_) for x_ in [1, 2, 3] for y_ in [3, 1, 4] if x_ != y_]

# 8.2.4. Оператор del
# Если нужно удалить элемент из списка, указав его индекс, а не значение, вы можете
# использовать оператор del. Он отличается от метода рор ( ) , который еще и возвращает
# значение элемента. Оператор del также можно использовать для удаления фрагмента списка
# или очистки всего списка. Например:

# x_ = [-2, -4, 5, 8, 2.2, 44]
# del x_[0]
# x_

# del x_[2:4]
# x_

# Оператор del можно использовать для удаления целых переменных:
# del х

# 8.3. Кортежи 1
# Кортеж состоит из ряда значений, разделенных запятыми, например:

t_ = 1234, 5678, " xyz "  # здесь переменная t - это кортеж
t_

u_ = t_, (" a ", " b ", " c ")  # кортеж u, состоящий из вложенных кортежей
u_

# Нельзя менять отдельные элементы кортежа, но можно создавать кортежи, которые 
# содержат внутри себя изменяемые объекты, такие как списки. Кортежи похожи на
# списки, но с двумя отличиями.
# ♦ Кортежи неизменяемы, а списки изменяемы.
# ♦ Кортежи заключаются в круглые скобки, а списки - в квадратные.
# Разница:
# ♦ Хотя кортежи и похожи на списки, они часто используются в разных ситуациях
# и для разных целей.
# ♦ Кортежи неизменяемы и обычно содержат неоднородную последовательность
# элементов, доступ к которым осуществляется посредством распаковки или ин-
# дексации (или по имени атрибута в случае именованных кортежей).
# ♦ Списки изменяемы, их элементы обычно однородны, а доступ к ним осуществ-
# ляется путем перебора списка.
# Где и почему лучше использовать кортежи вместо списков?
# ♦ Когда важна скорость выполнения программы, предпочтительнее использовать
# кортежи. Программа с кортежами выполняется быстрее по сравнению с такой
# же программой, но на списках. Но при использовании небольших кортежей и
# списков разница не ощущается.
# ♦ Когда важна целостность данных и вы не хотите, чтобы ваши данные изменя-
# лись во время выполнения программы. Использование кортежа вместо списка
# защищает данные от случайного изменения во время выполнения (помните, что
# кортежи неизменяемы).
# ♦ Кортежи можно использовать в качестве ключа к словарю, а вот списки - нельзя.
# Т.к. ключи должны быть неизменяемы.
# 8.3.1. Методы кортежей
# Почти все методы списков также применимы и к кортежам. Так как кортежи неизменяемы,
# следовательно, методы и функции, которые изменяют списки, для кортежей использоваться
# не могут.
#
# 8.4. Множества
# Множество - это неупорядоченная коллекция неповторяющихся элементов. Они используются
# в основном для проверки вхождения элементов во множество и для устранения
# дубликатов. Множества также поддерживают математические операции, такие как
# объединение, пересечение, разность и симметричная разность.
# Множество - это неупорядоченный тип данных, который является итерируемым,
# изменяемым и не имеет повторяющихся элементов. Класс множества в Python со-
# ответствует математическим множествам1 •
# Поскольку множества не упорядочены, к их элементам нельзя получить доступ
# через индекс.
# Для создания множеств можно использовать фиrурные скобки {} или функцию
# set().

colours = {" red", "black", " blue", "orange", "red", "pink", "white"}
colours

# быстрая проверка на вхождение в множество
"red" in colours

"purple" in colours

# ПРИМЕЧАНИЕ
# Для создания пустого множества нужно использовать функцию set() , а не {}, т. к. 
# пустые фигурные скобки создают пустой словарь.
#

# 8.4.1. Операции над множествами
# Множества поддерживают те же операции, что и в работе с математическими множествами.

# уникальные буквы в словах
# a_ = set("abracadabra")
# b_ = set("alacazam")
# a_  # уникальные буквы
# {'a', 'b', 'r', 'c', 'd'}
#
# b_  # уникальные буквы
# {'a', 'c', 'l', 'm', 'z'}
#
# a_ - b_  # буквы, которые есть в множестве а, но не в b
# {'b', 'd', 'r'}
#
# a_ | b_  # буквы, которые есть в а, или ь, или в обоих множества
# {'a', 'b', 'c', 'd', 'l', 'm', 'r', 'z'}
#
# a_ & b_  # буквы, которые есть в множествах а и b одновременно
# {'a', 'c'}
#
# a_ ^ b_  # буквы, которые есть в а или b, но не в обоих сразу
# {'b', 'd', 'l', 'm', 'r', 'z'}
#
# oперации, аналогичные списковым включениям, применимы и для множеств:
# a_ = {x_ for x_ in "abracadabra " if x_ not in "abc"}
# a_
# {' ', 'd', 'r'}

# 8.4.2. Методы множеств
# Практически все методы списков также применимы и к множествам. Множества не
# упорядочены, поэтому методы, использующие индексацюо, здесь не используются.
# add()  -  Добавляет элемент в множество
# сору()  -  Возвращает копию множества
# clear()  -  Удаляет все элементы из множества
# discard()  -   Удаляет указанный элемент из множества
# рор()  -  Удаляет произвольный элемент из множества
# remove()  -  Удаляет указанный элемент. Если такого элемента нет в множестве, вернется ошибка
# symmetric_difference()  -  Возвращает симметричную разность двух множеств
# syrmnetric_difference_update()  -  Вставляет симметричную разность этого множества и другого
# union()  -  Возвращает объединение множеств
# difference()  -  Возвращает разницу между двумя или более множествами
# difference_update()  -  Удаляет элементы из этого множества, которые также включены в другое
# множество
# update()  -  Объединяет множество с другим
# intersection()  -  Возвращает пересечение двух других множеств
# intersection_update()  -  Удаляет из множества элементы, которых нет в другом множестве
# isdisjoint()  -  Проверяет, есть ли у двух множеств пересечение
# issubset()  -  Проверяет, является ли это множество подмножеством другого
# issuperset()  -  Проверяет, является ли другое множество подмножеством первого

# 8.5. Словари
# Словарь - это еще один встроенный тип данных Python. Это неупорядоченный
# набор единиц данных. Лучше всего рассматривать словарь как пары ключ : значение с требованием о том,
# чтобы ключи в пределах одного словаря были уникальными. Пустой словарь создается с помощью пары
# фигурных скобок {}. Затем через запятую перечисляются пары ключ: значение.
# Словарь также можно создать с помощью встроенной функции dict().

# Ключ в словаре - это уникальный и неизменяемый тип данных, такой как строка,
# число или кортеж. Другими словами, в качестве ключей можно использовать только
# простые типы данных.

# небольшой nример словаря из телефонных номеров друзей
household = {"ramesh": 9893200000, "surabhi": 9893200311}
household

# добавить нового друга
household["sush"] = 9893200422
household

# словарь индексируется no ключам, а не по порядку,
# как список или строка
household["surabhi"]

# Конструктор dict {} строит словарь непосредственно из последовательности пар
# ( ключ, значение):

dict([("sape", 4139), ("guido", 4127), ("jack", 4098)])

# Для создания словарей из произвольных выражений для ключей и значений можно
# использовать синтаксис, аналогичный списковым включениям.

# Квадраты чисел
{x_: x_**2 for x_ in (2, 3, 4, 5)}

# 8.5.1 . Методы словарей
#
# сору() -  Возвращает копиию словаря
# clear() -  Удаляет все элементы из словаря
# рор() -  Возвращает значение ключа и удаляет эту пару из словаря
# popitem() -  Удаляет произвольную пару из словаря и возвращает ее как кортеж
# get() -  Обычный метод доступа к значению ключа
# values() -  Возвращает список всех значений словаря
# str() -  Создает строковое представление словаря
# update() -  Добавляет в словарь или обновляет пары из другого словаря
# setdefault() -  Возвращает значение ключа, если он есть в словаре, или добавляет его
# в словарь со значением по умолчанию
# keys() -  Возвращает список всех ключей словаря
# items() -  Возвращает список, содержащий кортеж для каждой пары «ключ - значение»
# has_key() -  Возвращает true, если ключ присутствует в словаре, иначе false
# fromkeys() -  Создает новый словарь с ключами из указанной последовательности
# и заданными значениями по умолчанию
# type() -  Возвращает тип переданной переменной
# cmp() -  Сравнивает элементы двух словарей

# 8.6. Перебор последовательностей в цикле
# При циклическом просмотре словаря ключ и соответствующее значение можно
# получить одновременно с помощью метода items().

knights = {"Gallahad": "the pure", "Robin": "the brave"}
for k_, v_ in knights.items():
    print(k_, v_)

# При переборе последовательности индекс позиции и соответствующее значение
# можно получить одновременно с помощью функции enumerate().

for i_, v_ in enumerate(["tic", "tac", "toe"]):
    print(i_, v_)

# При совместном переборе двух или более последовательностей можно объединять
# записи с помощью функции zip().

questions = ["name", "quest", "favorite color"]
answers = ["Lancelot", "the Holy Grail", "blue"]
for q_, a_ in zip(questions, answers):
    print(f" What is your {q_}? It is {a_}.")

# Чтобы перебрать последовательность в обратном порядке, сначала укажите после
# довательность в прямом порядке, а затем вызовите функцию reversed().

for i_ in reversed(range(1, 10, 2)):
    print(i_)

# Чтобы перебрать последовательность в отсортированном порядке, используйте
# функцию sorted(), которая возвращает новый отсортированный список, оставляя
# исходный список неизменным.

basket = ["apple", "orange", "apple", "pear", "orange", "banana"]
for f_ in sorted(set(basket)):
    print(f_)

# 8.7. Резюме
# 1. Я изучила строки и их методы, форматирование и операции, как можно изменять строки, 
# хотя они и неизменяемы.
# 2. Узнала, что списки - это один из самых популярных типов данных, в котором можно 
# хранить что угодно, они изменяемы, и ими можно элегантно управлять с помощью списковых
# включений.
# 3. Изучила такой тп данных, как кортежи, которые очень похожи на списки, но они неизме-
# няемы, поэтому используются по-другому.
# 4. Изучила множества, узнала,что они не упорядочены, и, следовательно, от них нельзя
# брать индекс или срез, как от списков. Они содержат только уникальные значения и
# используются там, где нужна определенная функциональность.
# 5. Изучила словари, данные в которых хранятся в виде пар «ключ - значение». 

# 8.8.1. Ответьте на вопросы
# 1. В чем разница между числами и строками в Python? Они взаимозаменяемы?
# Ответ:
# Числа и строки - это два разных класса в Python Int и str. Они не взаимоваменяемые.
# 2. Как работает новый метод форматирования строк, представленный в версии
# Python 3.6?
# Ответ: Этот метод называется f -строками f' '
# 3 . Какие типы данных и последовательности могут храниться в списке?
# Ответ: любые
# 4. Какой результат даст приведенный оператор? Обоснуйте ответ.
# print ('let\'s get back to work')
# Вывод строки на экран.
# 5. Списки можно изменять, но кортежи неизменяемы. Как вы понимаете это ут-
# верждение? Как это влияет на использование обоих этих типов данных?
# К спискам могут быть применимы методы, которые вносят изменения, по сути 
# списки - это всего лишь контейнеры для хранения различных типов данных. в 
# то время как к кортежам такие методы пременены быть не могут, следовательно они
# используются, когда необходимо защитить данные от изменений. Также они занимают
# меньше места, операции над ними намного быстрее.
# 6. Какому оператору эквивалентны списковые включения? Чем они полезнее?
# оператору for
# Списковые включения - элегантнее и быстрее.
# 7. Кортежи представляют собой упорядоченную коллекцию, а множества - не
# упорядоченную коллекцию. Как вы понимаете это утверждение? Как это влияет
# на использование обоих этих типов?
# Упорядоченная коллекция - это такая коллекция, у которой каждый элемент находится
# на определенном месте и имеет свой индекс.Соответственно к элементам неупорядоченных 
# коллекций нельзя получить доступ через индекс. Часто можества используют для того,
# чтобы убрать дубликаты.
# 8. Если требуется хранить уникальные элементы любого текста или коллекции, какой
# тип лучше использовать? Приведите пример, когда это может быть полезно.
# Уникальные элементы могут хранится в словарях в качестве ключей.
# 9. Являются ли словари итерируемыми? Продумайте ответ.
# Словари являются итерируемыми

# 1. Одну и ту же строку можно изменять с помощью строковых методов и сохра  -
# нять ее в той же области памяти. ЛОЖЬ
# 2. Операция умножения строки на число возвращает строку с повторяющимися
# значениями. ПРАВДА
# 3. Строки различаются в зависимости от используемых кавычек.ЛОЖЬ
# 4. Индексирование работает со строками и списками, но не со множествами. ЛОЖЬ
# 5. В списках может храниться только один тип данных. ЛОЖЬ
# 6. Вставлять новое значение в кортеж нельзя. ПРАВДА
# 7. Списковые включения - это элегантный метод управления списками. ПРАВДА
# 8. Кортеж может содержать разные типы данных. ПРАВДА
# 9. Кортежи заключаются в круглые скобки( ) , а списки заключаются в квадратные
# скобки[ ]. ПРАВА
# 10. В словаре количество ключей и значений не обязательно должно быть одина
# ковым. ПРАВДА

# 1 . Используйте списковые включения для создания следующих списков:
# а) [ ' С ' , ' О ' , ' U ' , ' N ' , ' Т ' , ' R ' , ' У ' ]
# б) [ ' С ' , ' А ' , ' Т ' , ' СС ' , ' АА ' , ' ТТ ' , ' ССС ' , ' ААА ' , ' ТТТ ' ]
# в) [ [ 2 ] , [ 3 ] , [ 4 ] , [ 3 ] , [ 4 ] , [ 5 ] , [ 4 ] , [ 5 ] , [ 6 ] ]
# г) [ [ 2 , 3 , 4 , 5 ] , [ 3 , 4 , 5 , 6 ] , [ 4 , 5 , 6 , 7 ] , ( 5 , 6 , 7 , 8 ] ]
# д) [ ( 1 , 1 ) , ( 2 , 1 ) , ( 3 , 1 ) , ( 1 , 2 ) , ( 2 , 2 ) , ( 3 , 2 ) , ( 1 , 3 ) , ( 2 , 3 ) , ( 3 , 3 ) ]
# е) [ 0 , 1 , 4 , 9 , 1 6 , 2 5 , 3 6, 4 9 , 64 , 8 1 ]

print(list("COUNTRY"))

print([char * i_ for i_ in range(1, 4) for char in "CAT"])

print([[j_] for i_ in range(3) for j_ in range(i_ + 2, i_ + 2 + 3)])

print([list(range(i_ + 2, i_ + 2 + 4)) for i_ in range(4)])

print([(j_, i_) for i_ in range(1, 4) for j_ in range(1, 4)])

print([i_**2 for i_ in range(10)])

# 2. Создайте пустой список. Допустим, он называется my_list. Заполните его
# 50 числами от 1 до 25 (числа могут повторяться).

my_list = [random.randint(1, 25) for _ in range(50)]
print(my_list)

# 3. В списке my_list, созданном в предыдущем пункте, выполните поиск и узнайте, есть ли в нем числа 11, 18 и 20.
# Напишите код для поиска этих чисел. Кроме того, подсчитайте, сколько раз встречаются эти числа в списке.

for num in (11, 18, 20):
    if num in my_list:
        print(f"Число {num} входит в список my_list {my_list.count(num)} раз")
    else:
        print(f"Число {num} не входит в список my_list")


# 4. Напишите код для вывода информации о том, сколько четных и нечетных чисел
# в списке my_list.

def get_even(lst: List[int]) -> int:
    """Find quantity of even numbers."""
    return len(list(x_ for x_ in lst if x_ % 2 == 0))


print(f"Четных чисел в списке my_list: {get_even(my_list)}")


def odd(lst: List[int]) -> int:
    """Find quantity of odd numbers."""
    return len(list(x_ for x_ in lst if x_ % 2 != 0))


print(f"Нечетных чисел в списке my_list: {odd(my_list)}")


# 5. Напишите код для создания из my_list другого списка, в котором числа равны
# квадрату чисел в my_list, но в обратном порядке.

def reversed_sqrts(lst: List[int]) -> List[int]:
    """Find square of numbers."""
    sqrts = [x_**2 for x_ in lst]
    return list(reversed(sqrts))


print(reversed_sqrts(my_list))


# 6.Напишите функцию sorted_list(), которая принимает в качестве параметра спи-
# сок и возвращает True, если список отсортирован в порядке возрастания, и False
# в противном случае. В качестве дополнительного условия вы можете считать,
# что элементы списка можно сравнивать с помощью операторов отношения <, >
# и т. д.

def is_sorted(lst: List[int], reverse: bool = False) -> bool:
    """Define sorted list."""
    return all(
        lst[i_] <= lst[i_ + 1] if not reverse else lst[i_] >= lst[i_ + 1]
        for i_ in range(len(lst) - 1)
    )


print(is_sorted(my_list))

print(is_sorted(list(sorted(my_list))))

# 7. Напишите программу Python для вывода имен и номеров телефонов 10 ваших друзей, сохранения их в словаре и вывода номера телефона по заданному имени.

# +
# telephone_book: dict = {}  # type: ignore
# for _ in range(10):
#     name, number = input("Введите имя и номер").split()
#     if name in telephone_book:
#         telephone_book[name].append(number)
#     else:
#         telephone_book[name] = [number]
# print(telephone_book)

# while True:
#     serching_name = input()
#     if serching_name == "end":
#         break
#     if serching_name in telephone_book:
#         print(telephone_book[serching_name])
#     else:
#         print("Нет в телефонной книге")

# +
from typing import Dict

telephone_book: Dict[str, int] = {}
for _ in range(2):
    name, number = input("Введите имя и номер").split()
    if name not in telephone_book:
        telephone_book[name] = int(number)
print(telephone_book)

while True:
    serching_name = input()
    if serching_name == "end":
        break
    if serching_name in telephone_book:
        print(telephone_book[serching_name])
    else:
        print("Нет в телефонной книге")


# -

# 8. Напишите функцию, remove_duplicates(), которая принимает в качестве параметра список и возвращает новый список, содержащий только уникальные элементы из первого списка. Подсказка: они не обязательно должны сохранять порядок.

# +
def remove_duplicates(lst: List[int]) -> List[int]:
    """Remove_duplicates."""
    return list(set(lst))


my_list = [random.randint(1, 100) for _ in range(30)]
print(my_list)
print(remove_duplicates(my_list))
# -

# 9. Напишите функцию для вычисления произведения элементов списка. Что произойдет, если в функцию передать список строк?

# +
my_list = [random.randint(1, 100) for _ in range(10)]
product = 1
for i_ in my_list:
    product *= i_

print(f"Весь список: {my_list}")
print(f"Произведение элементов списка: {product}")
