# ---
# jupyter:
#   jupytext:
#     text_representation:
#       extension: .py
#       format_name: light
#       format_version: '1.5'
#       jupytext_version: 1.16.4
#   kernelspec:
#     display_name: Python 3
#     language: python
#     name: python3
# ---

"""Функции."""


# 6.1 . Определение функций
# Первый вопрос, на который нам нужно ответить: что такое функция?
# В Python функция - это группа связанных операторов, выполняющих определен-
# ную задачу.
# С помощью функций можно разбить программу на более мелкие части. По мере
# того как наша программа становится все больше и больше, функции становятся все
# более и более необходимы для поддержания организованности и управляемости
# кода.
# Как и все остальное в Python, функции тоже являются объектами.
# В функцию можно передавать данные, называемые параметрами. Функция может
# возвращать данные как результат своей работы. Чтобы вызвать функцию, нужно
# указать имя функции, за которым следуют круглые скобки () с параметрами. На
# пример, функция len (х) возвращает длину параметра х.
# 6.2. Типы функций
# Функции бывают двух типов.
# ♦ Встроенные функции уже определены в Python и могут быть вызваны напря
# мую.
# ♦ Пользовательские функции - это объекты, которые создаются пользователем
# с помощью явного определения. Функция вызывается с тем же количеством ар-
# гументов, что и в формальном описании функции.
#
# 6.3. Встроенные функции
# В круглых скобках указываются объекты, который нужно передать функции в ка
# честве аргумента.
# ♦ аЬs (х) возвращает абсолютное значение числа. Аргумент может быть целым
# числом или числом с плавающей точкой. Если аргумент - комплексное число,
# возвращается его абсолютное значение.
# ♦ any (iteraЬle) возвращает тrue, если какой-либо элемент переданной последова
# тельности истинен. Если итерируемый объект пуст, возвращается False.
# ♦ chr (i) возвращает строку, представляющую собой символ, кодировка которого
# в таблице Unicode равна i. 
# ♦ dir ([oЬject]) при вызове без аргумента возвращает список имен всех локальных
# объектов. С аргументом возвращает список допустимых атрибутов для передан
# ного объекта.
# ♦ float ([x]) возвращает число с плавающей точкой, полученное из числа или
# строки х.
# ♦ help ([oЬject]) - это вызов встроенной справочной системы (эта функция пред
# назначена для интерактивного использования). При вызове без аргумента на
# консоли интерпретатора запускается интерактивная справочная система. Если
# аргумент является строкой, то ищется соответствующее имя модуля, функции,
# класса, метода, ключевого слова или раздела документации, а на консоли выво
# дится страница справки. Если аргумент является объектом любого другого типа,
# для этого объекта создается справочная страница.
# ♦ id (oЬject) возвращает идентификатор объекта. Это целое число, которое гаран
# тированно будет уникальным и постоянным для этого объекта в течение всего
# его времени жизни. Два объекта с неперекрывающимся временем жизни могут
# иметь одинаковое значение id ( ) . С точки зрения реализации CPython это адрес
# объекта в памяти.
# ♦ input ( [prompt] ) используется для получения ввода от пользователя. Если передан
# аргумент, он выводится в стандартный поток вывода без символа новой строки
# в конце.
# ♦ int ([x]) возвращает целочисленный объект, сформированный из числа или стро
# ки х.
# ♦ isinstance (oЬject, classinfo) возвращает True, если аргумент object является эк
# земпляром класса classinfo или его подклассом (прямым, косвенным или вирту
# альным). Если объект не является объектом данного типа, функция возвращает
# False.
# ♦ len (s) возвращает длину (количество элементов) переданного объекта. В качест
# ве аргумента можно передать последовательность (например, строку, байтовую
# строку, кортеж, список или диапазон) или коллекцию (словарь, множество или
# замороженное множество).
# ♦ шар (function, i teraЬle [ , . . . ] ) возвращает итератор, который применяет передан
# ную функцию к каждому элементу переданного итерируемого объекта. Если
# в функцию map ( ) передается несколько итерируемых аргументов, то указанная
# функция function ( ) должна принимать такое же количество аргументов и будет
# применяться к элементам из всех итерируемых аргументов параллельно. При
# этом итератор остановится, когда дойдет до конца самого короткого из итери
# руемых объектов.
# ♦ mах (argl , arg2 , *args [ , key] ) возвращает наибольший элемент в итерируемом
# объекте или наибольший из переданных аргументов.
# ♦ min (argl , arg2, *args [ , key] ) возвращает наименьший элемент в итерируемом
# объекте или наименьший из переданных аргументов.
# ♦ open (file) открывает файл и возвращает соответствующий файловый объект.
# ♦ ord(c) принимает строку, состоящую из одного символа Unicode, и возвращает
# целое число, представляющее код Unicode этого символа. Например, ord ( ' а ' )
# возвращает 97, а ord ( ' € ' ) возвращает вз 64. Функция обратна chr ( ) .
# ♦ print (*oЬjects , sep=' ' , end= ' \n' , file=sys . stdout, flush=False) выводит объекты
# в текстовый поток с разделителями sep и окончанием end. Аргументы sep, end,
# file и flush, если они есть, должны быть указаны как именованные аргументы.
# Все неименованные аргументы преобразуются в строки функцией str ( ) и запи
# сываются в поток с разделителем sep и окончанием end. И sep, и end должны быть
# строками. Они могут иметь значение None, в результате чего будут использовать
# ся значения по умолчанию. Без аргументов функция print ( ) просто выводит пус
# тую строку.
# ♦ repr (oЬjects) возвращает строку, содержащую формальное строковое представ
# ление объекта.
# ♦ reversed(seq) возвращает итератор в обратном порядке.
# ♦ round(m.пaЬer [ , ndigits] ) округляет число с точностью до ndigits знаков после де
# сятичной точки. Если аргумент ndigi ts опущен или равен None, функция возвра
# щает ближайшее целое.
# ♦ sorted (iteraЬle , * , key=None , reverse=False) возвращает новый отсортированный
# список из элементов переданного итерируемого.
# ♦ type (oЬject) принимает один аргумент и возвращает его тип.
#
#
# 6.4. Пользовательские функции
# Это один из самых мощных инструментов большинства языков программирования,
# который позволяет пользователю писать свои собственные функции. Это дает без
# граничные возможности для создания повторно используемого кода для выполне
# ния повторяющихся задач.
# Встроенных функций не так много. Когда программисrу нужен функционал, кото
# рого нет во встроенной библиотеке, он создает его сам.
# 6.4.1. Зачем создавать функции?
# ♦ Создавая свои функции, программист избавляется от необходимости переписы
# вать один и тот же код снова и снова. Предположим, что в вашей программе есть
# фрагмент кода, который вычисляет процентную ставку. Если вы захотите рас
# считать процентную ставку для другой основной суммы и для другого периода
# времени в той же программе, вам явно не доставит удовольствия заново писать
# один и тот же код. Вместо этого вы бы предпочли повторить выполнение фраг
# мента кода, который вычисляет проценты, а затем вернуться к тому месту, где
# вы остановились. Этот фрагмент кода - не что иное, как функция.
# ♦ Лучше разбивать разные действия на отдельные функции, чем писать всю логи
# ку в одном месте. Так у программы будет модульная структура. Более мелкие
# функции могут повторно пригодиться в аналогичных ситуациях. А если вся ло
# гика объединена в одной крупной функции, вы не сможете повторно использо
# вать какую-то ее часть, придется написать еще один фрагмент кода.
# ♦ Разделение кода на функции упрощает разработку и понимание программы.
# Также, если работа программы может быть разделена на отдельные действия и
# каждое действие помещено в отдельную функцию, вы можете писать и прове
# рять фрагменты кода независимо друг от друга.
# 6.4.2. Создание и вызов функций
# Как и у всего остального, у создания (определения) функций есть собственный син
# таксис. Он весьма прост:
# 				def имя_функции() :
# 				тело_функции
# Когда мы пишем оператор def, интерпретатор Python понимает, что мы собираемся
# определить функцию. Совершенно очевидно, что «def» - это сокращение от англ.
# define (определять). Теперь мы должны дать нашей функции уникальное имя. По
# сле слова def следует имя функции, затем пара круглых скобок() и двоеточие (:).
# В следующей строке идет тело функции. Оно начинается с отступа, который сооб
# щает Python, что этот блок кода является телом функции. Тело функции - это не
# что иное, как код, который функция выполняет.
# Имя, которое мы даем нашей функции, должно быть уникальным, как и перемен-
# ные. Мы можем назвать нашу функцию как угодно, но необходимо при этом
# соблюдать правила языка Python. Кроме того, функцию следует наделять таким
# именем, которое связано с ее назначением, т. е. имеет смысл. 

def lemonade_stall(price: int) -> None:
    """Print lemonade content."""
    if price == 50:
        print("Лимонад сделан из :")
        print("Лимонный сок")
        print("Boдa")
        print("Coль")
        print("Caxap")
    elif price == 100:
        print("Sprite сделан из :")
        print("Лимонный сок")
        print("Coдoвaя")
        print("Caxap")
        print("Секретный ингредиент")
    else:
        print("Пожалуйста, заплатите нужную сумму")


lemonade_stall(80)


# 6.4.2.1. Количество аргументов
# Когда вы вызываете функцию, ей нужно передать правильное количество аргумен-
# тов. То есть если у функции определены 2 параметра, вы должны передать ей
# 2 аргумента, не больше и не меньше.

def my_name(first_name: str, last_name: str) -> None:
    """Print my_name."""
    print(first_name, last_name)


my_name("Nilabh", "Nishchhal")


# def fib(n_):
#     a_, b_ = 0, 1
#     while a_ < n_:
#         print(a_, end=" ")
#         a_, b_ = b_, a_ + b_
#         print()
#
#
# print(fib(100))

def fib2(n_: int) -> list:  # type: ignore
    """Fibonachi number."""
    result = []
    a_, b_ = 0, 1
    while a_ < n_:
        result.append(a_)
        a_, b_ = b_, a_ + b_
    return result


fib2(100)


# Оператор return возвращает значение из функции. Если после оператора return
# ничего не указать, возвращается None. Если этот оператор отсутствует в конце
# функции, тоже возвращается None.
#
# 6.5. Варианты передачи аргументов
# Существуют четыре варианта передачи аргументов, которые можно комбинировать.
# 1. Аргументы со значением по умолчанию.
# 2. Произвольное число аргументов (*args).
# 3. Именованные аргументы.
# 4. Произвольное число именованных аргументов (**kwargs)
#
# Наиболее полезный вариант - это указать для одного или нескольких аргументов
# значение по умолчанию. В этом случае функцию можно вызвать с меньшим коли-
# чеством аргументов, чем в ней определено.

def my_address(city: str, state: str, country: str = "India") -> None:
    """Print address."""
    print("I live in", city, ",", state, ",", country)


my_address("Mumbai", "Maharashtra")

my_address(" Sydney", "New South Wales", "Australia")


# Значение по умолчанию не означает, что это единственное значение, которое мо-
# жет принимать данный параметр. Вы можете передать в функцию любое другое
# значение. То есть если при вызове функции вы не указываете для этого аргумента
# значение, он принимает значение по умолчанию. 

# Если вы не знаете, сколько аргументов будет передано в вашу функцию, добавьте
# перед именем параметра в определении функции символ *.
# Таким образом, функция получит кортеж аргументов и сможет соответственно
# обращаться к элементам кортежа.

def fruit_basket(*fruit: str) -> None:
    """Print fruts."""
    print(fruit)


fruit_basket("apple", "grapes", "strawberry")


def parrot(
    volt: str,
    state: str = "мертв",
    action: str = "оживет",
    tip: str = "Норвежский голубой",
) -> None:
    """Parrot constructor."""
    print("- Этот попугай не", action, end=" ")
    print("дaжe если пропустить", volt, "вольт через него .")
    print("- Какое оперение! ", tip)
    print("- Он", state, "!")


parrot("тысяча")  # первый позиционный аргумент
parrot(volt="тысяча")  # первый именованный аргумент
parrot(volt="миллион", action="полетит")  # два именованных аргумента
parrot(action="полетит", volt="миллион")  # два именованных аргумента
parrot("миллион", "отправился к праотцам", "прыгнет")
parrot("тысячу", state="летает c ангелами")


# Если количество именованных аргументов, передаваемых в функцию, неиз-
# вестно, можно добавить перед именем параметра в определении функции две
# звездочки **.
# В этом случае функция получит словарь аргументов, из которого сможет
# получить доступ к его элементам по именам.

def try_function(*args: str, **kwargs: str) -> None:
    """Print week days."""
    print("args:", args)
    print("kwargs:", kwargs)


try_function(
    "Monday",
    "Tuesday",
    "Wednesday",
    fourth_="Thursday",
    fifth_="Friday",
    weekendl_="Saturday",
    weekend2_="Sunday",
)


# 6.6. Генераторы
# Генератор - это функция, возвращающая итератор. То есть эти функции генери-
# руют объект, который можно перебирать в цикле.
# Генератор - это особый класс функций. Вместо того, чтобы возвращать одно зна-
# чение, функция-генератор возвращает последовательность значений (объект -
# итератор). Слово return в таких функциях заменяется на yield. Если функция
# содержит хотя бы один оператор yield (а при этом она может содержать несколько
# yield или return), она становится функцией-генератором. Разница между return
# и yield заключается в том, что оператор return полностью завершает функцию,
# а оператор yield приостанавливает выполнение функции и сохраняет все ее
# локальные переменные, а затем продолжает выполнение с того же места при
# последующем вызове или итерации.

def inclusive_range(*args: int):  # type: ignore
    """Generate function."""
    numargs = len(args)
    start = 0
    step = 1

    if numargs < 1:
        raise TypeError(f"Expected at least one argument, got {numargs}")
    if numargs == 1:
        stop = args[0]
    elif numargs == 2:
        (start, stop) = args
    elif numargs == 3:
        (start, stop, step) = args
    else:
        raise TypeError("Expected at most 3 arguments, got {numargs}")

    begin = start
    while begin <= stop:
        yield begin
        begin += step


inclusive_range()

for i_ in inclusive_range(25):
    print(i_, end=" ")


# 6.7. Резюме
# 1. Изучила встроенные функции и рассмотрела самые полезные из них. 
# 2. Узнала как определять и вызывать собственные функции. 
# 3. ЗИзучила параметры и аргументы функции. 
# 4. Узнала, как можно более эффективно использовать разные аргументы 
# для вызова функции. 

# 6.8.1. Ответьте на вопросы
# 1. В чем различие между функцией и методом?
# Ответ:
# Методы связаны с объектами и могут изменять их состояние, в то время 
# как функции независимы от объектов.
# 2. Как создание своих функций помогает программисту в работе?
# Ответ:
# Дает безграничные возможности для создания повторно используемого
# кода для выполнения повторяющихся задач.
# 3. Чем ограничено тело функции? 
# Ответ:
# Тело функции - это блок кода, им же оно
# и ограничено.
# 4. Можно ли использовать функцию, находящуюся внутри модуля, за пределами
# модуля? 
# Ответ:
# Можно, если ее передать за пределы модуля
# 5. В чем сходство и различие параметров и аргументов функции?
# Ответ: 
# Параметры — это переменные, которые определяются в заголовке функции и 
# используются внутри неё. Аргументы — это значения, которые передаются в
# функцию при её вызове.
# 6. Зачем в определении функции нужен оператор return? Что вернет функция, если
# в ее определении нет оператора return?
# Ответ: 
# Если функция должна обработать какие-то данные и потом вернуть их, то
# для возвращения этих данных необходим этот оператор. Если в функции
# отсутствует оператор return или он используется без значения, функция вернёт
# None.
# 7. Как обозначается произвольное количество аргументов? Когда они использу-
# ются?
# Ответ: 
# Проивольное количество аргументов обозначается *args.  Внутри функции
# *args будет представлен в виде кортежа, содержащего все переданные аргументы.
# 8. Что такое функция-генератор? Чем она отличается от обычных функций?
# Ответ:
# Генератор — это объект, который сразу при создании не вычисляет значения всех
# своих элементов. Он хранит в памяти только последний вычисленный элемент,
# правило перехода к следующему и условие, при котором выполнение прерывается.
# Функция-генератор отличается от обычной функции тем, что вместо команды
# return в ней используется yield
# 9. В чем разница между args и kwargs? Что это такое?
# Ответ:
# **kwargs - это те же элементы, но именнованные
# *args позволяет передавать в функцию произвольное количество позиционных
# аргументов. **kwargs позволяет передавать произвольное количество именованных
# аргументов (аргументов с ключами).

# 6.8.2. Правда или ложь
# 1. Чтобы вернуть значение из функции, нужно использовать оператор return.
# ПРАВДА
# 2. Каждый оператор return в функции может возвращать свое значение.
# ПРАВДА
# 3. Функция обязательно должна возвращать какое-то значение.
# ЛОЖЬ
# 4. Функция, которая не возвращает никакого значения, возвращает None.
# ПРАВДА
# 5. При определении функции нужно указать хотя бы один параметр.
# ЛОЖЬ
# 6. Имя *args - это всего лишь соглашение. Вместо args можно использовать
# любое другое имя.
# ПРАВДА
# 7. Функция, которая выводит значения на экран, аналогична функции, возвра-
# щающей эти значения.
# ЛОЖЬ
# 8. Различные виды аргументов в одной функции определять нельзя.
# ЛОЖЬ
# 9. При использовании именованных аргументов их порядок не имеет значения.
# ПРАВДА
# 10. В функции-генераторе нужно использовать оператор yield вместо оператора
# return.
# ПРАВДА

# 6.8.3. Практические задания

# 1. Напишите функцию, которая проверяет, является ли год високосным.

def which_year(num: int) -> str:
    """Show leap year."""
    if num % 4 == 0:
        return f"{num} - високосный год"
    return f"{num} - не високосный год"


number = int(input("Введите год: "))
which_year(number)

# 2. Напишите функцию f(х), возвращающую простые множители любого числа х
# (пример простых множителей: 36 - [2 2 3 3], 30 - [2 3 5] ).

# +
x_ = int(input("1:>"))


def f_(num: int) -> list:  # type: ignore
    """Prime factors."""
    t_, res = 2, []
    while t_ * t_ <= num:
        if num % t_ == 0:
            res.append(t_)
            num //= t_
        else:
            t_ += 1
    if num > 1:
        res.append(num)
    return res


# -

print(f_(x_))

# 3.Напишите функцию для преобразования температуры из градусов Цельсия
# в градусы Фаренгейта. Напишите еще одну функцию для обратного преобразо
# вания.

# +
temperature = int(input("1:>"))


def converter_c_to_f(celsius: int) -> int:
    """Convert from celsius to foringate."""
    foringate = round((celsius * 9 / 5) + 32)
    return foringate


# -

print(converter_c_to_f(temperature))

# +
temperature = int(input("2:>"))


def converter_f_to_c(foringate: int) -> int:
    """Convert from celsius to foringate."""
    celsius = round((foringate - 32) * 5 / 9)
    return celsius


# -

print(converter_f_to_c(temperature))

# 4. Напишите функцию для вычисления факториала любого числа.

# +
number = int(input("3:>"))


def factorial(num: int) -> int:
    """Find factorial."""
    return 1 if num in (1, 0) else num * factorial(num - 1)


print(factorial(number))
# -

# 5. Напишите функцию преобразования любого числа от 1 до 100 в римское число.

# def integer_to_roman(num):
#     """Function converse integer to roman."""
#     romansdict = {
#         1: "I",
#         5: "V",
#         10: "X",
#         50: "L",
#         100: "C",
#     }
#
#     div = 1
#     while num >= div:
#         div *= 10
#
#     div /= 10
#
#     res = ""
#
#     while num:
#
#         lastnum = int(num / div)
#
#         if lastnum <= 3:
#             res += romansdict[div] * lastnum
#         elif lastnum == 4:
#             res += romansdict[div] + romansdict[div * 5]
#         elif 5 <= lastnum <= 8:
#             res += romansdict[div * 5] + (romansdict[div] * (lastnum - 5))
#         elif lastnum == 9:
#             res += romansdict[div] + romansdict[div * 10]
#
#         num = math.floor(num % div)
#         div /= 10
#
#     return res
#
#
#
# print(integer_to_roman(12))				

# 6. Напишите функцию f(х), которая возвращает таблицу умножения числа х.

# +
number = int(input("4:>"))


def multiplication_table(num: int) -> None:
    """Make multiplication table."""
    for i_num in range(1, 11):
        res = num * i_
        print(f"{num} * {i_num} = {res}")


multiplication_table(number)


# -

# 7. Напишите функцию, которая принимает в качестве входных данных список и
# возвращает его перевернутый вариант.

# +
def reverse_list(lst: str) -> None:
    """Revers list."""
    rev_list = lst[::-1]
    print(rev_list)


my_list = input("6:>")
reverse_list(my_list)
# -

# 8. Напишите функцию для расчета сложных процентов.

# +
summa = int(input("Сумма"))
number = int(input("Ставка"))
period = int(input("Лет"))


def calculate_profit(money: int, rate: int, years: int) -> None:
    """Calculate compound Interest."""
    for _ in range(years):
        percent = money * (1 + rate)
        print(percent)


calculate_profit(summa, number, period)


# -

# 9. Напишите функцию f(х) , где х - любое 6-значное число, а функция возвращает
# сумму его цифр.

# +
def make_summ(num: str) -> None:
    """Calculate sum."""
    summ = 0
    for i_num in num:
        summ += int(i_num)
    print(summ)


frase = "456789"
make_summ(frase)
# -

# 10. Напишите функцию, которая проверяет, является ли переданное число простым.

# +
number = int(input("5:>"))


def prime_number(num: int) -> None:
    """Determine prime number."""
    if num > 1:
        for i in range(2, (num // 2) + 1):
            if (num % i) == 0:
                print(False)
                break
            print(True)


prime_number(number)
