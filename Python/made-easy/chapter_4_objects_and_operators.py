# ---
# jupyter:
#   jupytext:
#     text_representation:
#       extension: .py
#       format_name: light
#       format_version: '1.5'
#       jupytext_version: 1.16.4
#   kernelspec:
#     display_name: Python 3
#     language: python
#     name: python3
# ---

# +
"""Объекты и операторы в Python."""


import keyword
# -

# 4.1 . Переменные
# Переменные в Python - это просто указатели. Сами по себе они не имеют значе-
# ний, а просто указывают на объект, который им присвоен. Технически перемен-
# ные - это просто области в памяти вашего компьютера, в которых хранится неко-
# торая информация. Значения переменных, как следует из самого слова «перемен-
# ная», могут меняться. 

x_ = 38
y_ = "emailid@python.com"
print(x_)
print(y_)

# Достаточно придумать имя переменной и присвоить ей значение, а Python
# автоматически определит ее тип.

print(type(x_))
print(type(y_))

# 4.1. Оператор присваивания
# Когда мы вводим переменную вида х = 38, то в этой записи х - это имя перемен
# ной, (=) - это оператор присваивания, а 38 - это присвоенное значение.
# Здесь, в отличие от арифметики, знак (=) не означает «равно». Он означает «при-
# своить». В Python «равно» записывается как ==.

print(keyword.kwlist)

# 4.2. Структура программы
# В программе на Python можно выделить такие части, как модули, выражения, опе-
# раторы и объекты.
# 1. Программы состоят из модулей.
# 2. Модули содержат выражения.
# 3. Выражения содержат операторы.
# 4. Операторы создают и обрабатывают объекты.
#
# 4.3. Объекты
# В Python все данные становятся объектами. Объекты могут быть либо встроенны-
# ми, которые есть в Python изначально, либо мы создаем их сами с помощью классов
# Python. Python поддерживает ООП, т. е. объектно-ориентированное
# программирование.
# Важной характеристикой языка Python является то, что его объектная модель очень
# последовательна. Каждая структура данных, число, строка, класс, функция, модуль
# и т. д. в интерпретаторе Python существуют в своем собственном «контейнере», ко-
# торый называется объектом Python. Каждый объект имеет связанный с ним тип
# (например, целое число, строка и т. д.) и его данные. На практике это делает язык
# очень гибким, поскольку даже с функциями можно обращаться так же, как и с лю-
# бым другим объектом.
# 4.3.1. Классификация объектов
#
# Объекты делятся по типу данных на:
# ♦ встроенные;
# ♦ пользовательские.
# Типы данных также бывают:
# ♦ изменяемые;
# ♦ неизменяемые.
#
# Типы объектов:
# Числа - неизменяемые
# Строки - неизменяемые
# Списки - изменяемые
# Словари - изменяемые
# Кортежи - неизменяемые
# Множества - изменяемые
# Логический тип - неизменяемые
# Компоненты программы (функции, модули, классы)
#
# 4.3.2. Преимущества встроенных типов
# Встроенные типы данных делают важную вещь, благодаря которой Python - это
# язык высокого уровня. Они уже определены, и пользоватеmо не приходится
# описывать все нужные объекты с нуля. Это экономит много времени и усилий,
# а также снижает количество ошибок. Если нет необходимости в особой
# обработке данных, которую встроенные типы необеспечивают, почти всегда
# лучше использовать встроенный тип данных, а не реализовывать свой
# собственный. 
# ♦ встроенные типы данных упрощают написание программ;
# ♦ встроенные типы - это компоненты расширений;
# ♦ встроенные типы часто более эффективны, чем пользовательские структуры
# данных;
# ♦ встроенные типы данных являются стандартной частью языка
# Независимо от того, создаете ли вы новые типы данных, ядро любой
# программы на Python всеравно состоит из встроенных типов данных.
# 4.3.3. Идентификаторы, значения и типы объектов
# Объекты - это абстракция данных Python. Любые данные в программе Python
# представлены либо объектами, либо отношениями между объектами.
# Объект можно представить как сочетание трех вещей:
# ♦ идентификатор;
# ♦ тип данных;
# ♦ значение.
# У каждого объекта есть идентификатор, тип и значение.
# Идентификатор объекта после его создания никогда не меняется. Это адрес объекта
# в памяти. В Python идентификатор объекта (или его адрес в памяти) представлен
# числом. Его можно посмотреть с помощью функции id ( ) .

a_ = 5  # переменная, которой присвоено значение 5
id(a_)  # адрес в памяти или идентификатор объекта

# Тип объекта определяет операции, которые объект поддерживает, а также возмож-
# ные значения для объектов этого типа. Функция type ( ) возвращает тип объекта.
# Как и идентификатор, тип объекта также нельзя изменять.

type(a_)

str

float

type(["x", "yz", "abc"])  # список, содержащий три строки

type(["x", "y", 1])

type({"food": "spam", "taste": "yum"})  # словарь

# 4.3.4. Изменяемые и неизменяемые объекты
# Некоторые объекты содержат ссылки на другие объекты, и тогда они называются
# контейнерами. Примерами контейнеров являются кортежи, списки и словари. Зна-
# чения контейнера - это ссылки на объекты. Но говоря об изменяемости контейнера,
# мы имеем в виду только адреса содержащихся в нем объектов. Так, если не-
# изменяемый контейнер (например, кортеж) содержит ссылку на изменяемый объект,
# значение контейнера изменится при изменении значения объекта. Однако контейнер
# попрежнему считается неизменяемым, поскольку набор содержащихся в нем объек-
# тов не может быть изменен.
#
# 4.4.1. Встроенные константы
# 1. None
# У этого типа данных одно-единственное значение. И есть только один объект
# с таким значением. Доступ к этому объекту осуществляется через встроенное
# имя None. Он используется для обозначения отсутствия значения, например воз-
# вращается из функций, которые ничего явно не возвращают. В логическом
# смысле эквивалентен False.
# 2. NotImplemented
# Числовые методы и методы сравнения должны возвращать этот объект, если они
# не реализуют операцию для предоставленных операндов. В логическом смысле
# эквивалентен True.
# 3. Ellipsis
# Доступ к этому объекту осуществляется через литерал . . . или встро-
# енное имя Ellipsis. В логическом смысле эквивалентен тrue.
# 4.4.2. Числовые типы
# Они создаются числовыми литералами и возвращаются арифметическими операто-
# рами и встроенными арифметическими функциями в качестве результата. 
# Python различает:
# 1. Целые числа (int)
# Это целые числа в неограниченном диапазоне, зависящем только от доступной
# (виртуальной) памяти. Для операций сдвига и маски используется двоичное
# представление, а отрицательные числа представлены в дополнительном коде,
# что создает иллюзию бесконечной строки знаковых битов, простирающейся
# влево.
# 2. Логические значения (bооl)
# Логический тип является подтипом целочисленного, т.к. логические значения
# ведут себя как значения О и 1 почти во всех случаях, за исключением того,
# что при преобразовании в строку возвращаются строки "True" и " False"
# соответственно.
# 3. Вещественные числа (float)
# Это числа с плавающей точкой двойной точности машинного уровня. Здесь диа-
# пазон значений и обработка переполнений задаются на уровне базовой машин-
# ной архитектуры (и реализации С или Java).
# 4. Комплексные числа (complex)
# Комплексные числа представляются как пара чисел с плавающей точкой двой-
# ной точности машинного уровня. Ограничения те же, что и у чисел с плавающей
# запятой. Действительную и мнимую части комплексного числа z можно полу
# чить с помощью атрибутов z.real и z.imag.
# 4.4.3. Последовательности
# Это конечные упорядоченные множества с индексацией неотрицательными числа
# ми. Встроенная функция len() возвращает количество элементов последователь
# ности. Когда длина последовательности равна n, ее индексы лежат в диапазоне
# О, 1 , ... , n - 1. Чтобы выбрать i-й элемент последовательности а, нужно 
# написать a[i].
# Последовательности также поддерживают операции срезов. Срез а[i:j] выбирает
# все элементы с таким индексом k, что выполняется неравенство i <= k < j . При
# использовании в выражении срез представляет собой последовательность того же
# типа. Это означает, что сам по себе срез тоже проиндексирован с О.
# Некоторые последовательности также поддерживают «расширенные срезы»
# с третьим параметром - шагом. Срез a [i:j:k] выбирает все элементы а с индек-
# сом х, где выполняются условия: х = i + n * k, n >= О и i <= х < j .
# Последовательности можно разделить на группы по признаку изменяемости.
# 4.4.3.1. Неизменяемые последовательности
# Неизменяемые последовательности не могут быть изменены после создания. Если
# объект содержит ссылки на другие объекты, то эти другие объекты могут изме-
# няться, но коллекция объектов, на которые ссылается эта неизменяемая последо
# вальность, измениться не может.
# Перечисленные типы являются неизменяемыми.
# 1. Строки (str)
# Строка - это последовательность значений, кодируемых таблицей Unicode.
# В Python нет типа char, а символы представляются как строки длиной 1 .
# Встроенная функция ord ( ) переводит код символа из строковой формы в целое
# число в диапазоне от о до l0FFFF, а функция chr ( ) преобразует целое число в
# диапазоне от 0 до 10FFFF в соответствующий строковый объект длиной 1 . 

ord("a")

print(chr(96))
print(chr(100))
print(chr(99))
print(chr(1045))
print(chr(100009))

# 2. Кортежи
# Элементами кортежа могут быть любые объекты Python. Кортеж из двух или
# более элементов формируется из списка выражений, разделенных запятыми.
# Кортеж из одного элемента можно создать путем добавления запятой к выраже-
# нию (выражение само по себе не является кортежем, а для группировки выраже-
# ний в кортеж необходимо использовать круглые скобки). Пустой кортеж можно
# задать пустой парой круглых скобок.
# Пример кортежа: ('xyz', 5, 'р').
# 3. Байтовые строки (bytes)
# Объект типа bytes - это неизменяемый массив. Его элементы представляют со
# бой 8-битные числа х, такие что о <= х < 256. Для создания байтовых строк 
# можно использовать байтовые литералы (например, Ь'аЬс') или встроенный конст-
# руктор bytes(). Кроме того, байтовые строки можно декодировать в строки с по
# мощью метода decode().
# 4.4.3.2. Изменяемые последовательности
# Изменяемые последовательности допускают их изменение после создания. При
# выполнении операций присваивания и удаления можно использовать индексы
# и срезы.
# 1. Списки (list)
# Элементами списка могут быть произвольные объекты Python. Списки форми-
# руются путем передачи списка выражений, разделенных запятыми, заключенно-
# го в квадратные скобки.
# Пример списка: ['xyz', 5, 'р'] .
# 2. Байтовые массивы (bytearray)
# Объект bytearray - это изменяемый массив. Такие массивы создаются встроен-
# ным конструктором bytearray(). Кроме того, что байтовые массивы являются
# изменяемыми (и, следовательно, нехешируемыми), у них тот же интерфейс и
# функциональность, что и у неизменяемых байтовых объектов.
# 4.4.4. Множества
# Множества - это неупорядоченные конечные наборы уникальных неизменяемых
# объектов. М ножества не индексируются, но можно перебирать их элементы в 
# цикле, а встроенная функция len ( ) возвращает количество элементов в 
# наборе. Обычно множества используются для быстрой проверки вхождения элемента,
# удаления дубликатов из последовательности и вычисления математических операций
# над множествами, таких как пересечение, объединение, разность и симметричная
# разность. Cуществуют два встроенных типа множеств:
# 1. Множества (set)
# Это изменяемые множества. Они создаются встроенным конструктором set()
# и впоследствии могут быть изменены некоторыми методами, такими как add().
# Пример множества: {"apple", "banana", "cherry"} .
# 2. Замороженные множества (frozenset)
# Это неизменяемые множества. Они создаются встроенным конструктором
# frozenset(). Поскольку этот тип является неизменяемым и хешируемым, его
# можно включать в другие множества или использовать в качестве ключа 
# словаря. Множества неупорядочены, поэтому их элементы возвращаются в
# случайном порядке, и у их элементов нет индекса.
# 4.4.5. Сопоставления
# Сопоставления представляют собой конечные наборы объектов, индексированных
# произвольными индексами. Обращение вида а[k] позволяет выбрать из сопоставле-
# ния, а элемент с индексом k. Этот синтаксис можно использовать в выражениях,
# в операторах присваиваний и в операторах del. Встроенная функция len() возвра-
# щает количество элементов в сопоставлении.
# В настоящее время в языке Python существует один тип сопоставления:
# 1. Словарь (dict)
# Словарь представляет собой конечный набор объектов с почти произвольными
# индексами (ключами). В качестве ключей можно использовать все типы, кроме
# типов вроде списков или других словарей, которые являются изменяемыми и
# сравниваются по значению, а не по идентификатору объекта. Все дело в том, что
# для эффективной реализации словарей требуется, чтобы хеш-значения ключей
# не менялись. Числовые типы, используемые в качестве ключей, подчиняются
# обычным правилам числового сравнения: если два числа являются равными (на
# пример, 1 и 1.0), то они оба могут использоваться для индексации одного и того
# же элемента словаря.
# Словари изменяемы. Создать словарь можно с помощью фигурных скобок {} .
# Пример словаря: {"марка" : "Форд" , "модель " : "Мустанг" , " год" : 1964}.
# 4.4.6. Вызываемые типы
# Это типы объектов, к которым может применяться операция вызова функции:
# 1. Встроенные функции
# Функция - это блок кода, который запускается только при ее вызове. В функ-
# цию можно передавать параметры. В конце выполнения функция может вернуть
# какие-то данные. Чтобы вызвать функцию, нужно написать имя функции, а за
# ним круглые скобки. Например, len ( ) - это функция, которая возвращает 
# длину строки.
# 2. Пользовательские функции
# Пользовательская функция создается с помощью определения функции. Функция
# вызывается со списком аргументов, в котором должно быть то же количество
# элементов, что и в списке формальных параметров функции в определении.
# 3. Методы
# Метод экземпляра объединяет класс, экземпляр класса и любой вызываемый
# объект (обычно пользовательскую функцию).
# 4. Встроенные методы
# На самом деле это то же самое, что и встроенные функции. Метод в Python по-
# хож на функцию, за исключением того, что он относится к объекту. Вызывая
# метод объекта, мы, вероятно, вносим в этот объект изменения. Таким образом,
# метод принадлежит классу. Примером является метод добавления элемента
# в список append().
# ПРИМЕЧАНИЕ
# • Методы, в отличие от функций, вызываются у конкретного объекта.
# • Функции вызываются сами по себе, т.е. они не привязаны к объектам.
# • Поскольку метод вызывается у объекта, он может обращаться к его внутренним
# данным.
# • Метод может изменять состояние объекта, а функции обычно что-то принимают
# на вход, а в ответ возвращают значение или выводят что-то на экран.
# 5. Классы
# Классы относятся к вызываемым объектам и объединяют в себе данные и функ-
# циональность. Создание нового класса позволяет создать новый тип объектов, а
# в дальнейшем и новые экземпляры этого типа. Каждый экземпляр класса хранит
# атрибуты, определяющие его состояние. Экземпляр класса также может иметь
# методы (определяемые этим классом), изменяющие его состояние.
# 4.4.7. Модули
# В целом модуль - это то же самое, что и библиотека кода, т.е. файл с набором
# функций, которые вы хотите добавить в свое приложение. Чтобы создать модуль,
# достаточно лишь сохранить нужный код в файле с расширением ру.
# После этого вновь созданный модуль можно импортировать с помощью оператора
# import.
# Модуль может содержать функции, а также переменные всех типов (массивы, сло-
# вари и т. д.). Модули являются базовым элементом кода Python и создаются с
# помощью оператора import или при вызове таких функций, как 
# importlib.import_module() или import().
#
# 4.5. Операции с объектами в Python
#
#

14 + 26  # целочисленное сложение

1.5 * 4  # умножение вещественных чисел

2**100  # 2 в степени 100

4 / 2  # деление всегда возвращает число с плавающей точкой

# 5 > 4

# 4.6. Операторы
# Код в основном состоит из выражений. Простой пример выражения - 2 + 3.
# В выражении можно выделить операторы и операнды. Операторы - это
# какие-то действия. Они могут быть представлены символами, такими как
# +, или специальными ключевыми словами. Операторам для работы нужные дан-
# ные, которые называются операндами. В приведенном примере числа 2 и 3 
# являются операндами.х на число у.
#
# 1. + (плюс)
# Складывает два объекта.
#    4 + 3 дает 7.
#    'а' + 'Ь' дает 'аЬ'.
# 2. - (минус)
# Выполняет вычитание одного числа из другого. Если первый операнд отсутст-
# вует, предполагается, что он равен нулю.
#   -2.8 дает отрицательное число.
#   70 - 34 дает 36.
# 3. * (умножение)
# Возвращает произведение двух чисел или повторяет строку заданное число раз.
#   2 * 3 дает 6.
#   'ля' * 3 дает 'ляляля'.
# 4. ** (степень)
#   х ** у возвращает х в степени у.
#   2 ** 3 возвращает 8.
# 5. / (деление)
#   х / у делит число 
#   -25.5 % 2.25 дает 1.5.
#   13 / 3 дает 4,333333333333333.
# 6. // (целочисленное деление)
# х // у делит х на у и округляет ответ до ближайшего целого числа. При этом,
# если одно из чисел является дробным, ответ тоже будет числом с плавающей
# точкой.
#   13 // 3 дает 4 .
#   -13 // з дает -5.
#   9 // 1.81 дает 4.О.
# 7. % (остаток от деления)
# Возвращает остаток от деления.
#   13 % 3 дает 1 .
# 4.6.1. Арифмети ческие операторы
#
# 		4.6.2. Операторы присваивания
#
# 		Оператор Выражение   Эквивалент
#    =        а =  Ь        -
#    +=        а += Ь    а = (а + Ь)
#    -=        а -= Ь    а = (а - Ь)  
#    *=        а *= Ь    а = (а * Ь)
#    /=        а /= Ь    а = (а / Ь)
#    %=        а %= Ь    а = (а % Ь)
#   //=        а //= Ь   а = (а // Ь)
#   **=        а **= b   а =(а ** Ь)
#
# Оператор += сначала добавляет к значению, содержащемуся в переменной а, 
# значение переменной ь. Затем он присваивает переменной а результат этого
# сложения. Все остальные операторы работают похожим образом: сначала выполняют
# арифметическую операцию между двумя значениями, а затем присваивают результат
# этой операции первой переменной.
# При выполнении оператора %= первый операнд а делится на второй операнд b, затем
# остаток от этого деления присваивается переменной а.
# 4.6.3. Операторы сравнения
# 1. == (равно)
# Проверяет равенство объектов. Например:
#   х = 2; у = 2 ; х == у возвращает True.
#   х = 'str'; у = 'str'; х == у возвращает False.
#   х = 'str'; у ='str'; х == у возвращает True.
# 2. ! = (не равно)
# Проверяет неравенство объектов. Например:
# х = 2; у = 3; х != у возвращает True.
# 3. < (меньше)
# х < у проверяет, действительно ли х меньше у. Как и все прочие операторы срав-
# нения, возвращает True или False.
# 6 < 4 дает False, а 4 < 6 дает True.
# Сравнения можно соединять в цепочки: например, 3 < 5 < 7 дает тrue.
# 4. > (больше)
# х > у проверяет, действительно ли х больше у.
# 6 > 4 возвращает True. Если оба операнда являются числами, они сначала приво-
# дятся к общему типу. В противном случае всегда возвращает False.
# 5. <= (меньше или равно)
# х <= у проверяет, действительно ли х меньше или равно у.
# х = 3; у = 6; х <= у возвращает True.
# 6. >= (больше или равно)
# х >= у проверяет, действительно ли х больше или равно у.
# х = 4 ; у = 3 ; х > = 3 возвращает True.
#
# 4.6.4. Логические операторы
# 1. not (логическое НЕ)
#   Если х равен True, возвращает False.
#   Если х равен False, возвращает тrue.
# 2. and (логическое И)
#   х and у возвращают значение False, если х равно False, в противном случае
# возвращается значение у.
#   Пусть х = False ; у = True. Тогда х and у возвращают False, поскольку х имеет
# значение False. В этом случае Python не будет вычислять значение у, по
# скольку знает, что левая часть выражения and имеет значение False, и поэтому
# все выражение будет равно False независимо от других значений. Это назы-
# вается сокращенной оценкой логического выражения.
# 3. or (логическое ИЛИ)
#   Если х равен True, возвращает True, иначе возвращает оценку у.
#   Пусть х = True; у = False. Тогда х or у возвращает True. Здесь также может
# выполняться сокращенная оценка.
# 4.6.5. Операторы идентификации и вхождения
# 1. Операторы идентификации проверяют идентичность двух объектов.
# 1.1. is
# Если  х - это тот же объект, что и у, выражение возвращает True. В про-
# тивном случае возвращается False.
# 1.2. is not
# Если х не является тем же объектом, что и у, выражение возвращает True.
# В противном случае возвращается False.
#
# 2.Операторы вхождении проверяют, является ли данный объект элементом дан-
# ной коллекции. Под «коллекцией» понимается последовательность или структу-
# ра данных, например строка, список, кортеж и т. д.
# 2.1. in
# Если х является элементом коллекции у, то возвращается True, в противном
# случае возвращается False.
# 2.2. not in
# Если х не является элементом коллекции у, возвращается True, в противном
# случае возвращается False.
#

4 == 2 * 2

# i is in 'string'

# x_ = [1, 2, 3, "three", 4]
# print(2 in x_)
# print(5 in x_)
# print("three" in x_)

# 4.7. Отступы
# Блок кода (тело функции, цикла и т. д.) начинается с отступа и заканчивается, когда
# появляется строка без такого отступа. Величина отступа остается на усмотрение
# программиста, но она должна быть одинаковой во всем блоке.
# Обычно для отступа используются четыре пробела, и такой способ считается
# предпочтительнее табуляции. 

# if True:
#     print('Hello')

# Неправильный отступ приводит к возникновению ошибки IndentationError.
#
# 4.8. Комментарии в Python
# Комментарии при написании программы весьма полезны. Они делают код более
# читабельным и позволяют понять, что делается в программе. В Python 
# комментарии начинаются с символа решетки #. Интерпретатор Python комментарии
# игнорирует.
# 4.9. Порядок выполнения
#
# Оператор                               Описание
# (выражения . . . ),                Запаковка кортежа, списка, словаря или множества
# [выражения • . . ],
# {ключ: значение . . . },
# {выражения . . . }
#
# х [индекс],                       Индексация, срезы, вызовы, ссылки на атрибуты
# х [индекс: индекс],
# х (аргументы . . .),
# x.attribute
#
# await х                           Оператор await
#
# **                                Возведение в степень
#
# +х, -х, ~х                        Смена знака числа, побитовое НЕ
#
# *, @, /, //, %                    Умножение, матричное умножение, деление,
#                                   целочисленное деление и остаток
#
# +, -                               Сложение, вычитание
#
# <<, >>                            Сдвиг
#
# &                                 Побитовое И
#
# ^                                 Побитовое исключающее ИЛИ
# in, not in, is, is not,           Сравнения, проверка вхождения и типа
# <1 <=, >, >=, != ==
#
# not х                             Логическое НЕ
#
# and                               Логическое И
#
# or                                Логическое ИЛИ
#
# if-else                           Условный оператор
#  
# lamЬda                            Лямбда-выражение
#
# Использование круглых скобок дает дополнительное преимущество - оно позво-
# ляет управлять порядком выполнения. Операторы с одинаковым приоритетом
# вычисляются слева направо. Исключение составляет только оператор
# возведения в степень ** - он имеет ассоциативность справа налево.
#

# вычисление площади прямоугольника
Length = 5
Width = 8
Area = Length * Width
print("Area of the Rectangle is", Area)
print("Perimeter of the rectangle is", 2 * (Length + Width))

# 4.10. Динамическая типизация
# В Python значение, на которое указывает переменная, имеет определенный тип
# данных, но сама переменная не имеет строгого типа. Вы можете повторно исполь-
# зовать одну и ту же переменную, передавая ей ссьmку на объект уже другого типа.
# Переменные можно считать «ярлыками», связанными с объектами.

# six = 6
# six

# six = "six"
# six

# 4.11. Строгая типизация
# Хотя Python позволяет гибко обходиться с типами данных, вам тем не менее нужно
# знать, объекты каких типов вы используете. Для некоторых операций требуются
# аргументы определенного типа.
# Пример:
# ' day ' + 1
# выдаст ошибку: TypeError : can only concatenate str (not "int " ) to str
# В Python тип объекта можно явно изменить с помощью встроенных функций.

print("day" + str(1))

# 4.12. Логическая и физическая строка
# Физическая строка кода - это то, что вы буквально видите на экране, когда пише-
# те программу. Логическая строка - это то, что Python считает единым выпол-
# няемым выражением. Python неявно предполагает, что каждая физическая строка
# соответствует логической строке.

# эдесь две физические и две логические строки
i = 5
print(i)

# эдесь одна физическая строка, но две логические
i = 5
print(i)

# Если вы хотите записать более одной логической строки на одной физической
# строке, вы должны использовать точку с запятой (; ), которая отмечает конец 
# логической строки/оператора. Python поощряет использование одного выражения 
# в строке. Это делает ваш код более читабельным.
#
# 4.13. Резюме
# 1. Изучила семантику языка Python.
# 2. Рассмотрела иерархию и структуру кода Python. 
# 3. Узнала, что в Python все является объектом. 
# 4. Узнала о разных типах объектов и их иерархии. 
# 5. Поняла, что выражения, операторы
# и операнды - это основные строительные блоки любой программы. 

# 4.14.1 . Ответьте на вопросы
# 1. Что такое переменная в Python? Чем она отличается от объекта?
# Ответ: Переменная в Python - это именованное хранилище для объектов. 
# 2. Каковы правила именования переменных в Python? Напишите, какие имена
# можно использовать, а какие нельзя.
# Ответ: Нельязя использовать зарезервированные имена, начинающиеся с цифры,
# в два и более слова, не латиницей
# 3. В чем преимущества встроенных типов данных?
# Ответ: Автоматическое определение типа данных.
# 4. Что такое неизменяемый объект? Какие объекты в Python неизменяемы?
# Ответ: Объект в который после создания нельзя внести изменения. Числа,
# строки, кортежи, логические выражения
# 5. Что называется идентификатором объекта? Чем он отличается от типа?
# Ответ: Идентификатор объекта - это  адрес объекта в памяти. Тип объекта
# определяет операции, которые объект поддерживает, а также возможные 
# значения для объектов этого типа.
# 6. Что делают функции chr ( ) и ord ( ) ? Как они связаны?
# Ответ: это встроенные функции в Python, которые предоставляют возможность
# преобразования символов в их числовое представление и обратно
# 7. Что такое оператор? Сколько типов операторов существует в Python? Назовите
# их все.
# Ответ: Операторы - это какие-то действия. Все операторы в Python можно разбить на группы:
# 1. Арифметические операторы
# 2. Операторы присваивания
# 3. Операторы сравнения
# 4. Логические операторы
# 5. Операторы идентификации и вхождения
#

# 4.14.2. Правда или ложь
# 1. Переменные в Python получают присвоенное им значение.
# Правда
# 2. В Python перед созданием переменной необходимо сначала определить ее тип.
# Ложь
# 3. Выражения х = 38 и х == 38 означают не одно и то же.
# Ложь
# 4. В Python мы выполняем операции над объектами.
# Правда
# 5. Ключевые слова Python можно использовать в качестве имен переменных.
# Ложь
# 6. Пользовательские типы данных работают эффективнее, чем встроенные.
# Ложь
# 7. Идентификатор объекта никогда не меняется после его создания.
# Правдв
# 8. Комментарии делают программу более читаемой и простой для понимания.
# Правдв
# 9. Отступы - это лишь украшение и способ сделать программу более красивой
# и читаемой.
# Ложь
# 10. Оператор % возвращает остаток от деления двух чисел.
# Правда

# 4.14.3. Практические задания
# 1. Питер получает зарплату 12 ООО в месяц. Напишите код для вычисления его 
# сбережений к концу года, если он будет откладывать 20% своей зарплаты каждый
# месяц.

salary = 12000
perc = 20 / 100
save_money = salary * perc * 12
save_money

# 2. Расстояние между Мумбаи и Дели составляет 1422 км. Если Сундар едет на ма-
# шине со средней скоростью 72 км/ч, сколько времени ему потребуется, чтобы
# преодолеть это расстояние?

distance = 1422
speed = 72
time = distance / speed
time

# 3. Температура тела человека находится в диапазоне от 97 до 99° по Фаренгейту.
# Как этот диапазон будет выглядеть в градусах Цельсия?

C1_ = round((97 - 32) * 5 / 9, 2)
C2_ = round((99 - 32) * 5 / 9, 2)
print(f"Температура тела print от {C1_} до {C2_} по Цельсию")

# 4. Пусть дано шестизначное число. Напишите программу для вычисления суммы
# всех цифр этого числа.

num = "456789"
summ = 0
for i_ in num:
    summ += int(i_)
print(summ)

# 5. У нас есть данные о месячных продажах 5 книжных магазинов в Бруклине:
# А = $ 6500, В = $ 8000, С = $ 12ООО, D = $ 4900 и Е = $ 5600.
# Предполагая, что в Бруклине всего 5 книжных магазинов, узнайте рыночную
# долю каждого магазина. Также проверьте, какой будет сумма рыночных долей
# всех магазинов. (Рыночная доля означает отношение одного участника ко всем
# остальным.)

# +
shop_a = 6500
shop_b = 8000
shop_c = 12000
shop_d = 4900
shop_e = 5600

all_shops = shop_a + shop_b + shop_c + shop_d + shop_e
a_share = round(shop_a / all_shops * 100)
b_share = round(shop_b / all_shops * 100)
c_share = round(shop_c / all_shops * 100)
d_share = round(shop_d / all_shops * 100)
e_share = round(shop_e / all_shops * 100)
print(f"Рыночная доля магазина A: {a_share} %")
print(f"Рыночная доля магазина B: {b_share} %")
print(f"Рыночная доля магазина C: {c_share} %")
print(f"Рыночная доля магазина D: {d_share} %")
print(f"Рыночная доля магазина E: {e_share} %")
summ = a_share + b_share + c_share + d_share + e_share
summ
# -

# 6. Среднее значение трех чисел равно 45. Первое число больше среднего значения
# настолько же, насколько второе число меньше среднего значения. Найдите
# третье число.
#

# def find_numbers(agv):
#     num_sum = agv * 3
#
#     for x_ in range(num_sum + 1):
#         for y_ in range(num_sum + 1):
#             for z_ in range(num_sum + 1):
#                 if (
#                     x_ > agv
#                     and y_ < agv
#                     and x_ - agv == agv - y_
#                     and (x_ + y_ + z_) // 3 == agv
#                 ):
#                     return z_
#
#
# print(find_numbers(45))

# 7. Джон покупает мобильный телефон за 1800 в Калькутте и продает его в Мум-
# баи с прибылью 25%. Если его накладные расходы составляют 5% от цены
# продажи, то какова цена продажи?

# +
price = 1800
sale_profit = 25 * 1800 * 0.01
sale_costs = 5 * 0.01

sale_price = (price + sale_profit) / (1 - sale_costs)
print(sale_price)
# -

# 8. Найдите объем и площадь куба с диагональю 5 м.

# +
diameter = 5

volume = diameter**3 / (3 * 3**0.5)
square = 2 * diameter**2

print(f"Объем куба равен: {volume}")
print(f"Площадь куба равна: {square}")
# -

# 9. Три металлических куба с ребрами длиной 3, 4 и 5 см соответственно пере
# плавляются в один куб. Найдите длину ребра нового куба.

# +
cube_1 = 3**3
cube_2 = 4**3
cube_3 = 5**3

cube_4 = (cube_1 + cube_2 + cube_3) ** (1 / 3)
print(round(cube_4, 2))
# -

# 10. Дано шестизначное число. Напишите программу для получения числа с обрат-
# ным порядком цифр.

num = input("Введите число: ")
num_rev = "".join(reversed(num))
print(num)
print(num_rev)
